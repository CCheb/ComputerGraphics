<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
	<Title>Spooky Forest</TITLE>
		
		<!-- 
		GLSL is the language used for shaders (GL Shader Language)
		
		Attribute - you specify how to pull the data out of the buffers you supply.
		Buffers - Data loaded onto the GPU (Normally vertex information)
		
		Uniforms - global variables (in GLSL) that you set before you run the shader program
		
		Textures - Textures are arrays of data you can randomly acces in your shader program.  
		
		Varying - are way for a vertex shader to pass data to the fragmentShader.
		-->
		<script id="2dVertexShader" type="notjs">
		attribute vec4 a_position;	
		//We now want to read in Colors
		attribute vec3 vert_color;
		//However, we want to send the color to
		//The fragment Shader
		varying vec3 fragColor;
				
		uniform vec3 transform;
		uniform vec3 rotation;		
		
		uniform vec3 worldLoc;
		uniform vec3 worldRotation;

		// Torch positions
		uniform vec3 torchLoc1;
		uniform vec3 torchLoc2;
		uniform vec3 torchLoc3;
		uniform vec3 torchLoc4;
		uniform vec3 torchLoc5;

		// Spotlight positions
		uniform vec3 spotLoc1;
		uniform vec3 spotLoc2;
		uniform vec3 spotLoc3;
		uniform vec3 spotLoc4;
		uniform vec3 spotLoc5;

		uniform float n;
		uniform float f;
		uniform float r;
		uniform float t;

		uniform float aspect;
		uniform float fov;

		

		//Lighting. The idea is to implement a simple version of the phong model
		// Make array to index each light, or create variable for each light

		// Remember that vectors dont have translation values and are instead used 
		// to specify direction in this case. You can implicitly think of these
		// vectors being along side their respective vertex but it makes not difference
		varying vec3 fakenormal;
		varying vec3 v_surfaceToView;	// V vector
		
		// Point lights
		varying vec3 v_surfaceToLight;	// L vector
		varying vec3 v_surfaceToLight2;
		varying vec3 v_surfaceToLight3;
		varying vec3 v_surfaceToLight4;
		varying vec3 v_surfaceToLight5;
		
		// Spot lights
		varying vec3 v_spot_surfaceToLight;	
		varying vec3 v_spot_surfaceToLight2;
		varying vec3 v_spot_surfaceToLight3;
		varying vec3 v_spot_surfaceToLight4;
		varying vec3 v_spot_surfaceToLight5;
		
		
		vec4 MoveCamera(vec4 pos)
		{
			vec3 cw = cos(worldRotation);
			vec3 sw = sin(worldRotation);
			mat4 translateView = mat4(1.0,0.0,0.0,0.0,
									  0.0,1.0,0.0,0.0,
									  0.0,0.0,1.0,0.0,
									  -1.0*worldLoc.x,-1.0*worldLoc.y,worldLoc.z,1.0
									);
						
			mat4 rotateView = mat4(cw.y,0.0,-1.0*sw.y,0.0,
									0.0,1.0,0.0,0.0,
									sw.y,0.0,cw.y,0.0,
									0.0,0.0,0.0,1.0);
			return rotateView*translateView*pos;
		}
		
		vec4 ApplyProjection(vec4 pos)
		{
			mat4 SimpleOrtho = mat4  (1,0.0,0.0,0.0,
							 0.0,1,0.0,0.0, 
							 0.0,0.0,1,0.0, 
							 0.0,0.0,0.0,1.0);

			// Negative x and y will flip the world back to normal, if we go that route
			mat4 ComplexPerspective = mat4(
										-1.0*fov/aspect, 0.0,0.0,0.0,
										0.0, -1.0*fov,0.0,0.0,
										0.0,0.0,-1.0*(f+n)/(f-n),-1.0,
										0.0,0.0,-2.0*f*n/(f-n),0.0
										);
			mat4 ComplexOrtho = mat4(	1.0/r,0.0,0.0,0.0,
										0.0,1.0/t,0.0,0.0,	//If I make the y -1.0/t I will invert the Y-axis.
										0.0,0.0,1.0,0.0,
										0.0,0.0,0.0,1.0	//If I make the x and y translate -1, -1 I can put 0,0 in the bottom right.
									);
									
			mat4 SimplePerspective = 	mat4(
								1.0,0.0,0.0,0.0,
								0.0,1.0,0.0,0.0,
								0.0,0.0,-1.0,-1.0,
								0.0,0.0,-2.0,0.0			
								);
			return ComplexPerspective*pos;
		}
		
		vec4 PositionObject(vec4 pos)
		{
			mat4 translateM = mat4(1.0,0.0,0.0,0.0,
						   0.0,1.0,0.0,0.0,
						   0.0,0.0,1.0,0.0,
						   transform.x,transform.y,transform.z,1.0);
			return translateM*pos;	
		}
		//Use a function to Rotate the object
		vec4 RotateObject(vec4 pos)
		{
			//This is a nice trick
			vec3 c = cos(rotation);
			vec3 s = sin(rotation);
			fragColor = vert_color;
			//Surprise!  we have to go column firt when we enter the matrix.

			//mat4 rotateX = mat4();
			mat4 rotateY = mat4(c.y,0.0,-1.0*s.y,0.0,
								0.0,1.0,0.0,0.0,
								s.y,0.0,c.y,0.0,
								0.0,0.0,0.0,1.0);
			//mat4 rotateZ = mat4();
			return rotateY*pos;
		}
		void main()
		{
			// Idea with fake normals is to have them spawn from the
			// center of the object and have them shoot out from there
			// these are not real normals. Ideally, each vertex should have its
			// own normals. We are mimicking an object with spherical normals

			// Spherical effect on objects
			// from edge to center
			// If the vertex from an object is greater than 5 then we consider this object
			// to be the floor and thus set its normal facing directly up
			if(length(a_position)<5.0)
			{
				//fakenormal = vec3(a_position);
				// need to adjust the normal to where the
				// verticie is facing
				fakenormal = RotateObject(a_position).xyz;

				
			}
			else
			{
				// Ground planes normal will be up always
				fakenormal = vec3(0.0,1.0,0.0);
			}
			vec4 worldSpace = PositionObject(RotateObject(a_position));

			// Lighting stuff
			// The position of the point light. Moved it back in the -z direction
			// Position doesnt have to be a constant, it can be a uniform
			// rising the position of the surface in the y will cause the floor to be
			// less lit. Remember: point - point = vector
			// vec3(0,0,-4)
			v_surfaceToLight = torchLoc1 - worldSpace.xyz;
			v_surfaceToLight2 = torchLoc2 - worldSpace.xyz;
			v_surfaceToLight3 = torchLoc3 - worldSpace.xyz;
			v_surfaceToLight4 = torchLoc4 - worldSpace.xyz;
			v_surfaceToLight5 = torchLoc5 - worldSpace.xyz;

			//v_surfaceToLight2 = vec3(-5,0,0) - worldSpace.xyz;

			// To make the light move with the world as the camera rotates and moves
			// The vector that points from the vertex over to the camera. Can be used for calculating specularity
			v_surfaceToView = worldLoc - worldSpace.xyz;
			// vec3(5.0,0.0,-2.0)

			v_spot_surfaceToLight = spotLoc1 - worldSpace.xyz;
			v_spot_surfaceToLight2 = spotLoc2 - worldSpace.xyz;
			v_spot_surfaceToLight3 = spotLoc3 - worldSpace.xyz;
			v_spot_surfaceToLight4 = spotLoc4 - worldSpace.xyz;
			v_spot_surfaceToLight5 = spotLoc5 - worldSpace.xyz;

			fragColor = vert_color;

			vec4 cameraSpace = MoveCamera(worldSpace);
			gl_Position = ApplyProjection(cameraSpace);


			//fragColor = vert_color;
			//vec4 worldCord = PositionObject(RotateObject(a_position));
			//vec4 cameraSpace = MoveCamera(worldCord);
			
			//gl_Position=ApplyProjection(cameraSpace);
		}		
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
		//Fragment shaders do not have precision so we have to set it.
		precision mediump float;
		varying vec3 fragColor;

		// As long as their are facing in the correct direction, we should be good on lighting
		varying vec3 fakenormal;
		varying vec3 v_surfaceToView;
		
		varying vec3 v_surfaceToLight;
		varying vec3 v_surfaceToLight2;
		varying vec3 v_surfaceToLight3;
		varying vec3 v_surfaceToLight4;
		varying vec3 v_surfaceToLight5;
		
		varying vec3 v_spot_surfaceToLight;
		varying vec3 v_spot_surfaceToLight2;
		varying vec3 v_spot_surfaceToLight3;
		varying vec3 v_spot_surfaceToLight4;
		varying vec3 v_spot_surfaceToLight5;

		void main()
		{
			// Main idea is to multiply the fragColor with a value that will either
			// make it brighter (towards 1) or darker (towards 0). At the end these colors 
			// will get interpolated by the fragment shader. All normalization is done here
			// in the fragment shader

			// AMBIENT
			float ambient = 0.1;
			// expects a vec4 to consider the alpha 
			//gl_FragColor = vec4(ambient*fragColor,1);

			// DISTANCE LIGHT
			// Need to normalize since we are looking for unit vectors
			// Second normalize is where the directional light is facing/pointing
			// The angle between them tells you how much the point is being lit
			float d_light = 0.25*(dot(normalize(fakenormal),normalize(vec3(20.0,5.0,20.0))));
			if(d_light < 0.0)
			{
				// Dont want negative light
				// Ground will not be lit when facing up
				d_light = 0.0;
			}
			//gl_FragColor = vec4(fragColor*(ambient + d_light),1);	// Only need to do this once

			// POINT LIGHT
			// Latter expression specifies the distance fall off so that objects that are far away from the
			// point light will be less lit. This value is optional
			float p_light = dot(normalize(fakenormal),normalize(v_surfaceToLight))*8.0/length(v_surfaceToLight);
			if(p_light < 0.0)
			{
				p_light = 0.0;
			}
			//gl_FragColor = vec4(fragColor*(p_light + d_light + ambient),1);


			
			float p_light2 = dot(normalize(fakenormal),normalize(v_surfaceToLight2))*8.0/length(v_surfaceToLight2);
			if(p_light2 < 0.0)
			{
				p_light2 = 0.0;
			}
			//gl_FragColor = vec4(fragColor*(p_light + p_light2 + d_light + ambient),1);

			float p_light3 = dot(normalize(fakenormal),normalize(v_surfaceToLight3))*8.0/length(v_surfaceToLight3);
			if(p_light3 < 0.0)
			{
				p_light3 = 0.0;
			}

			float p_light4 = dot(normalize(fakenormal),normalize(v_surfaceToLight4))*8.0/length(v_surfaceToLight4);
			if(p_light4 < 0.0)
			{
				p_light4 = 0.0;
			}

			float p_light5 = dot(normalize(fakenormal),normalize(v_surfaceToLight5))*8.0/length(v_surfaceToLight5);
			if(p_light5 < 0.0)
			{
				p_light5 = 0.0;
			}
			


			// SPOT LIGHT
			float spot_light_power = 0.0;
			float spot_light = dot(normalize(v_spot_surfaceToLight),vec3(0.0,1.0,0.0));
			
			// Specifies the cone size. If the object lies inside of the cone, that is, the dot product
			// between the surface and the spot light is >= 98 then its going to be lit by the spotlight
			// if not then dont light the object by the spotlight. 98
			if(spot_light >= 0.88)
			{
			
				spot_light_power = dot(normalize(fakenormal),normalize(v_spot_surfaceToLight));
				if(spot_light_power < 0.0)
				{
					spot_light_power = 0.0;
				}
			
			}

			

			float spot_light_power2 = 0.0;
			float spot_light2 = dot(normalize(v_spot_surfaceToLight2),vec3(0.0,1.0,0.0));
			
			if(spot_light2 >= 0.88)
			{
				spot_light_power2 = dot(normalize(fakenormal),normalize(v_spot_surfaceToLight2));
				if(spot_light_power2 < 0.0)
				{
					spot_light_power2 = 0.0;
				}
			
			}


			float spot_light_power3 = 0.0;
			float spot_light3 = dot(normalize(v_spot_surfaceToLight3),vec3(0.0,1.0,0.0));
			if(spot_light3 >= 0.88)
			{
				spot_light_power3 = dot(normalize(fakenormal),normalize(v_spot_surfaceToLight3));
				if(spot_light_power3 < 0.0)
				{
					spot_light_power3 = 0.0;
				}
			
			}

			float spot_light_power4 = 0.0;
			float spot_light4 = dot(normalize(v_spot_surfaceToLight4),vec3(0.0,1.0,0.0));
			if(spot_light4 >= 0.88)
			{
			
				spot_light_power4 = dot(normalize(fakenormal),normalize(v_spot_surfaceToLight4));
				if(spot_light_power4 < 0.0)
				{
					spot_light_power4 = 0.0;
				}
			
			}

			float spot_light_power5 = 0.0;
			float spot_light5 = dot(normalize(v_spot_surfaceToLight5),vec3(0.0,1.0,0.0));
			if(spot_light5 >= 0.88)
			{
				spot_light_power5 = dot(normalize(fakenormal),normalize(v_spot_surfaceToLight5));
				if(spot_light_power5 < 0.0)
				{
					spot_light_power5 = 0.0;
				}
			}

			//gl_FragColor = vec4(fragColor*(spot_light_power),1);
			gl_FragColor = vec4(fragColor*(p_light + p_light2 + p_light3 + p_light4 + p_light5 + d_light + ambient + spot_light_power + spot_light_power2 + spot_light_power3 + spot_light_power4 + spot_light_power5),1);

		}
		</script>
		
		<script>
			class WebGL_Interface
			{
				constructor()
				{
					this.vertexShaderSource = document.getElementById("2dVertexShader").text;
					this.fragmentShaderSource = document.getElementById("2dFragmentShader").text;
					this.vertexShader = this.createShader(gl.VERTEX_SHADER, this.vertexShaderSource);
					this.fragmenShader = this.createShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
					//Link to program
					this.program = this.createProgram(this.vertexShader,this.fragmenShader);
					//setup our viewport
					gl.viewport(0,0, gl.canvas.width, gl.canvas.height);
					//set clear colors
					gl.clearColor(0,0,0,1);
					gl.clear(gl.COLOR_BUFFER_BIT);		
					//what progbram to use;
					
					//We will need this for now!
					gl.enable(gl.DEPTH_TEST);
					
					gl.useProgram(this.program);
					
					var camLoc  = gl.getUniformLocation(this.program,'worldLoc');
					gl.uniform3fv(camLoc,new Float32Array([0,0,0]));
					var worldLoc = gl.getUniformLocation(this.program,'worldRotation');
					gl.uniform3fv(worldLoc,new Float32Array([0,0,0]));
					
					var tempLoc = gl.getUniformLocation(this.program,'n');
					gl.uniform1f(tempLoc,.1); //.1
					tempLoc = gl.getUniformLocation(this.program,'f');
					gl.uniform1f(tempLoc,500);
					tempLoc = gl.getUniformLocation(this.program,'r');
					gl.uniform1f(tempLoc,.1);
					tempLoc = gl.getUniformLocation(this.program,'t');
					gl.uniform1f(tempLoc,.06);

					// Defining the aspect ratio
					var aspect = gl.getUniformLocation(this.program, 'aspect');
					var a = gl.canvas.width / gl.canvas.height;
					gl.uniform1f(aspect, a);
						
					// Defining the field of view
					var field = gl.getUniformLocation(this.program, 'fov');
					var fov = Math.tan(2.37); // ~120 degrees
					gl.uniform1f(field, fov);
					
				}
				
				createShader(type,source)
				{
					var shader = gl.createShader(type);
					gl.shaderSource(shader,source);
					gl.compileShader(shader);
					var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
					if(success)
					{
						return shader;
					}
					//Else it didn't work
					console.error(gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
				}
				
				createProgram(vs,fs)
				{
					var program = gl.createProgram();
					gl.attachShader(program,vs);
					gl.attachShader(program,fs);
					gl.linkProgram(program);
					var succsess = gl.getProgramParameter(program,gl.LINK_STATUS);
					if(succsess)
					{
						return program;
					}
					console.error(gl.getProgramInfoLog(program));
					gl.deleteProgram(program);	
				}

			}
		</script>		

		<script>
			class Transform
			{
				constructor()
				{
					this.forward = [0,0,1];
					this.right = [1,0,0];
					this.up = [0,1,0];
				}

				doRotations(RotAngles)
				{
					this.xRot = [
								[1,0,0,0],
								[0,Math.cos(RotAngles[0]),Math.sin(RotAngles[0]),0],
								[0,-1*Math.sin(RotAngles[0]),Math.cos(RotAngles[0]),0],
								[0,0,0,1]
							];		
					this.yRot = [
							[Math.cos(RotAngles[1]),0,Math.sin(RotAngles[1]),0],
							[0,1,0,0],
							[-1*Math.sin(RotAngles[1]),0,Math.cos(RotAngles[1]),0],
							[0,0,0,1]	
							];
					this.zRot = [
								[Math.cos(RotAngles[2]),Math.sin(RotAngles[2]),0,0],
								[-1*Math.sin(RotAngles[2]),Math.cos(RotAngles[2]),0,0],
								[0,0,1,0],
								[0,0,0,1]
							]
					//this.forward = this.crossMultiply(xRot,[0,0,1,0]);		
					this.forward = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,0,1,0])))
					this.right = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[1,0,0,0])))
					this.up = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,1,0,0])))
				}			
				crossMultiply(M,V)
				{
					//console.log(M[0][3]);
					//console.log(V[3]);
					var temp = [
								M[0][0]*V[0]+M[0][1]*V[1]+M[0][2] * V[2]+ M[0][3]*V[3],
								M[1][0]*V[0]+M[1][1]*V[1]+M[1][2] * V[2]+ M[1][3]*V[3],
								M[2][0]*V[0]+M[2][1]*V[1]+M[2][2] * V[2]+ M[2][3]*V[3],
								M[3][0]*V[0]+M[3][1]*V[1]+M[3][2] * V[2]+ M[3][3]*V[3]
								]
					//console.log(temp);
					return temp;
				}
				
			}


			class GameObject
			{
				constructor(tCount, pType) 
				{
					this.loc = [0,0,0];
					this.rot = [0,0,0];
					this.isTrigger = false;
					this.cRadX = 1.0;
					this.cRadY = 1.0;
					this.cRadZ = 1.0;
					this.velocity = [0,0,0];
					this.angVelocity = [0,0,0];
					this.name = "default";
					this.id = 0;
					this.prefab;
					
					this.triangleCount = tCount;
					this.primitiveType = pType;
					this.transform = new Transform();
				}
				
				Move()
				{
					var tempP = [0,0,0];
					for(var i =0; i < 3;i ++)
					{
						tempP[i] = this.loc[i];
						tempP[i] += this.velocity[i];
						this.rot[i] += this.angVelocity[i];
					}
					// If any of the rotation values reach 360 degrees (6.28319~), reset back to 0 degrees
					if(!this.isTrigger)
					{
						var clear = true;
						for(var so in m.Solid)
						{
							if(m.Solid[so] != this)
							{
								if(m.CheckCollision(this.name,tempP, this.cRadX, this.cRadY, this.cRadZ, m.Solid[so].name, m.Solid[so].loc, m.Solid[so].cRadX, m.Solid[so].cRadY, m.Solid[so].cRadZ))
								{
									this.OnCollisionEnter(m.Solid[so])
								
									try
									{
										m.Solid[so].OnCollisionEnter(this);
									}
									catch{}
								
									clear = false;
								}
							}
						} 
						if(clear)
						{
							this.loc = tempP;
						}
					}
					else
					{  
						this.loc = tempP;
						// Check the trigger object against any solid objects
						for(var so in m.Solid)
						{
							// If we already collided with the solid object earlier and it has a OnTriggerEnter then
							// we can simply store it and use it here
							if(m.CheckCollision(this.name,tempP, this.cRadX, this.cRadY, this.cRadZ, m.Solid[so].name, m.Solid[so].loc, m.Solid[so].cRadX, m.Solid[so].cRadY, m.Solid[so].cRadZ))
							{
								// If there is a detected collision then call the TriggerEnter function from the
								// object thats listening for collisions, in this case the trigger object
								this.OnTriggerEnter(m.Solid[so]);
								try
								{
									m.Solid[so].OnTriggerEnter(this);
								}
								catch
								{}
							}
						
						}
						// Now check trigger with trigger just in case
						for(var to in m.Trigger)
						{ 	//this should be correct. It is trying to check for trigger objects insted of solid objects
							if(this != m.Trigger[to]){
								if(m.CheckCollision(this.name,tempP, this.cRadX, this.cRadY, this.cRadZ, m.Trigger[to].name, m.Trigger[to].loc, m.Trigger[to].cRadX, m.Trigger[to].cRadY, m.Trigger[to].cRadZ))
								{
									this.OnTriggerEnter(m.Trigger[to]);
									try
									{
										m.Trigger[to].OnTriggerEnter(this);
									}
									catch
									{}
								}
							}
						}
					}
				}

				OnCollisionEnter(other){}

				OnTriggerEnter(other){}
				

				Render(program)
				{

					var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					var size = 3;          // 2 components per iteration
					var type = gl.FLOAT;   // the data is 32bit floats
					var normalize = false; // don't normalize the data
					var stride = 6*Float32Array.BYTES_PER_ELEMENT;	//Size in bytes of each element     // 0 = move forward size * sizeof(type) each iteration to get the next position
					var offset = 0;        // start at the beginning of the buffer
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);
					
					//Now we have to do this for color
					var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");
					//We don't have to bind because we already have the correct buffer bound.
					size = 3;
					type = gl.FLOAT;
					normalize = false;
					stride = 6*Float32Array.BYTES_PER_ELEMENT;	//Size in bytes of each element
					offset = 3*Float32Array.BYTES_PER_ELEMENT;									//size of the offset
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);
							
					var tranLoc  = gl.getUniformLocation(program,'transform');
					gl.uniform3fv(tranLoc,new Float32Array(this.loc));
					var thetaLoc = gl.getUniformLocation(program,'rotation');
					gl.uniform3fv(thetaLoc,new Float32Array(this.rot));
				
					//var ibuffer = gl.createBuffer();
					//gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.ibuffer);
					//gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(this.indexOrder),gl.STATIC_DRAW);
					//gl.drawElements(gl.TRIANGLES,this.indexOrder.length,gl.UNSIGNED_BYTE,0);
					gl.drawArrays(this.primitiveType, 0, this.triangleCount);
				}

				Update()
				{
					console.error(this.name +" update() is NOT IMPLEMENTED!");
				}
				
			}


			class Ground extends GameObject
			{
				constructor()
				{
					super(4, gl.TRIANGLE_STRIP);
					this.name = "Ground";
					this.buffer=gl.createBuffer();
					this.colorBuffer = gl.createBuffer();
					
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices =
					[
						-1000,0,-1000,0,1,0,
						1000,0, -1000,0,1,0,
						-1000,0,1000,0,1,0,
						1000, 0,1000,0,1,0
						
					];
				
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc=[0,0,0];
					this.rot=[0,0,0];
				}
				Update()
				{
					//Do Nothing
				}
				
			}


			class Hex extends GameObject
			{
				constructor()
				{
					//18
					super(150, gl.TRIANGLE_STRIP);
					this.name = "Hex";
					this.angVelocity = [0,.025,0];
					//this.isTrigger = false;
					this.buffer=gl.createBuffer();
					//this.colorBuffer = gl.createBuffer();
					
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices =
					[
						// Tree trunk
						-.5,-.5,-.25,.54,.27,.07,
						-.5, 1.5,-.25,.54,.27,.07,
						-.25,-.5,-.5,.54,.27,.07,
						-.25, 1.5,-.5,.54,.27,.07,
						.25,-.5,-.5,.54,.27,.07,
						.25,1.5,-.5,.54,.27,.07,
						.5,-.5,-.25,.54,.27,.07,
						.5, 1.5,-.25,.54,.27,.07,
						.5,-.5,.25,.54,.27,.07,
						.5, 1.5,.25,.54,.27,.07,
						.25,-.5,.5,.54,.27,.07,
						.25, 1.5,.5,.54,.27,.07,
						-.25,-.5,.5,.54,.27,.07,
						-.25, 1.5,.5,.54,.27,.07,
						-.5,-.5,.25,.54,.27,.07,
						-.5, 1.5,.25,.54,.27,.07,
						-.5, -.5,-.25,.54,.27,.07,
						-.5, 1.5,-.25,.54,.27,.07,







						// Bush section
						// 0.9
						0.7,2.4,0.7, 0.0,1.0,0.0, // a
						-0.7,2.4,-0.7, 0.0,1.0,0.0, // b
						-0.7,2.4,0.7, 0.0,1.0,0.0, // c
						0.7,2.4,0.7, 0.0,1.0,0.0, // d
						-0.7,2.4,-0.7, 0.0,1.0,0.0, // g
						0.7,2.4,-0.7, 0.0,1.0,0.0, // v

						0.4,2.0,1.1, 0.0,1.0,0.0, // a1
						0.9,2.0,0.9, 0.0,1.0,0.0, // b1
						0.7,2.4,0.7, 0.0,1.0,0.0, // d

						0.4,2.0,1.1, 0.0,1.0,0.0,  // a1
						0.7,2.4,0.7, 0.0,1.0,0.0,  // d
						-0.7,2.4,0.7, 0.0,1.0,0.0, // c

						-0.9,2.0,0.9, 0.0,1.0,0.0, // c1
						0.4,2.0,1.1, 0.0,1.0,0.0, // a1
						-0.7,2.4,0.7, 0.0,1.0,0.0, // c

						//15
						-1.1,2.0,0.4 , 0.0,1.0,0.0, // a2
						-0.9,2.0,0.9, 0.0,1.0,0.0, // c1
						-0.7,2.4,0.7, 0.0,1.0,0.0, // c

						//18
						-1.1,2.0,0.4, 0.0,1.0,0.0, // a2
						-0.7,2.4,0.7, 0.0,1.0,0.0, // c
						-0.7,2.4,-0.7, 0.0,1.0,0.0, // b

						//21
						-0.9,2.0,-0.9, 0.0,1.0,0.0, // b2
						-1.1,2.0,0.4 , 0.0,1.0,0.0, // a2
						-0.7,2.4,-0.7, 0.0,1.0,0.0, // g

						//23
						0.4,2.0,-1.1, 0.0,1.0,0.0, // a3
						-0.9,2.0,-0.9, 0.0,1.0,0.0, // b2
						-0.7,2.4,-0.7, 0.0,1.0,0.0, // g

						//26
						0.4,2.0,-1.1, 0.0,1.0,0.0, // a3
						-0.7,2.4,-0.7, 0.0,1.0,0.0, // g
						0.7,2.4,-0.7, 0.0,1.0,0.0, // v

						//29
						0.9,2.0,-0.9, 0.0,1.0,0.0, // b3
						0.4,2.0,-1.1, 0.0,1.0,0.0, // a3
						0.7,2.4,-0.7, 0.0,1.0,0.0, // v

						//32
						1.1,2.0,0.4, 0.0,1.0,0.0, // a4
						0.9,2.0,-0.9, 0.0,1.0,0.0, // b3
						0.7,2.4,-0.7, 0.0,1.0,0.0, // v

						//35
						1.1,2.0,0.4, 0.0,1.0,0.0, // a4
						0.7,2.4,-0.7, 0.0,1.0,0.0, // v
						0.7,2.4,0.7, 0.0,1.0,0.0, // d

						//42 // mid top
						0.9,2.0,0.9, 0.0,1.0,0.0, // b1
						1.1,2.0,0.4, 0.0,1.0,0.0, // a4
						0.7,2.4,0.7, 0.0,1.0,0.0, // d

						//45
						1.1,2.0,0.4, 0.0,1.0,0.0, // a4
						0.9,2.0,0.9, 0.0,1.0,0.0, // b1
						0.9,1.7,0.9, 0.0,1.0,0.0, // a5

						//48
						1.1,2.0,0.4, 0.0,1.0,0.0, // a4
						0.9,1.7,0.9, 0.0,1.0,0.0, // a5
						1.1,1.7,0.4, 0.0,1.0,0.0, // b5

						//51
						0.9,2.0,-0.9, 0.0,1.0,0.0, // b3
						1.1,2.0,0.4, 0.0,1.0,0.0, // a4
						1.1,1.7,0.4, 0.0,1.0,0.0, // b5

						//54
						0.9,2.0,-0.9, 0.0,1.0,0.0, // b3
						1.1,1.7,0.4, 0.0,1.0,0.0, // b5
						0.9,1.7,-0.9, 0.0,1.0,0.0, // a6

						//57
						0.4,2.0,-1.1, 0.0,1.0,0.0, // a3
						0.9,2.0,-0.9, 0.0,1.0,0.0, // b3
						0.9,1.7,-0.9, 0.0,1.0,0.0, // a6

						//60
						0.4,2.0,-1.1, 0.0,1.0,0.0, // a3
						0.9,1.7,-0.9, 0.0,1.0,0.0, // a6
						0.4,1.7,-1.1, 0.0,1.0,0.0, // b6

						-0.9,2.0,-0.9, 0.0,1.0,0.0, // b2
						0.4,2.0,-1.1, 0.0,1.0,0.0, // a3
						0.4,1.7,-1.1, 0.0,1.0,0.0, // b6

						-0.9,2.0,-0.9, 0.0,1.0,0.0, // b2
						0.4,1.7,-1.1, 0.0,1.0,0.0, // b6
						-0.9,1.7,-0.9, 0.0,1.0,0.0, // a7

						//69
						-1.1,2.0,0.4 , 0.0,1.0,0.0, // a2
						-0.9,2.0,-0.9, 0.0,1.0,0.0, // b2
						-0.9,1.7,-0.9, 0.0,1.0,0.0, // a7

						//72
						-1.1,2.0,0.4 , 0.0,1.0,0.0, // a2
						-0.9,1.7,-0.9, 0.0,1.0,0.0, // a7
						-1.1,1.7,0.4, 0.0,1.0,0.0, // a8

						//75
						-0.9,2.0,0.9, 0.0,1.0,0.0, // c1
						-1.1,2.0,0.4 , 0.0,1.0,0.0, // a2
						-1.1,1.7,0.4, 0.0,1.0,0.0, // a8

						//78
						-0.9,2.0,0.9, 0.0,1.0,0.0, // c1
						-1.1,1.7,0.4, 0.0,1.0,0.0, // a8
						-0.9,1.7,0.9, 0.0,1.0,0.0, // b8

						//80
						0.4,2.0,1.1, 0.0,1.0,0.0, // a1
						-0.9,2.0,0.9, 0.0,1.0,0.0, // c1
						-0.9,1.7,0.9, 0.0,1.0,0.0, // b8

						//83
						0.4,2.0,1.1, 0.0,1.0,0.0, // a1
						-0.9,1.7,0.9, 0.0,1.0,0.0, // b8
						0.4,1.7,1.1, 0.0,1.0,0.0, // a9

						//86
						0.9,2.0,0.9, 0.0,1.0,0.0, // b1
						0.4,2.0,1.1, 0.0,1.0,0.0, // a1
						0.4,1.7,1.1, 0.0,1.0,0.0, // a9

						//90
						0.9,2.0,0.9, 0.0,1.0,0.0, // b1
						0.4,1.7,1.1, 0.0,1.0,0.0, // a9
						0.9,1.7,0.9, 0.0,1.0,0.0, // a5


						// Bottom cap


						0.7,1.4,0.7, 0.0,1.0,0.0, // a
						-0.7,1.4,-0.7, 0.0,1.0,0.0, // b
						-0.7,1.4,0.7, 0.0,1.0,0.0, // c
						0.7,1.4,0.7, 0.0,1.0,0.0, // d
						-0.7,1.4,-0.7, 0.0,1.0,0.0, // g
						0.7,1.4,-0.7, 0.0,1.0,0.0, // v




						0.4,1.7,1.1, 0.0,1.0,0.0, // a1
						0.9,1.7,0.9, 0.0,1.0,0.0, // b1
						0.7,1.4,0.7, 0.0,1.0,0.0, // d

						0.4,1.7,1.1, 0.0,1.0,0.0,  // a1
						0.7,1.4,0.7, 0.0,1.0,0.0,  // d
						-0.7,1.4,0.7, 0.0,1.0,0.0, // c

						//99
						-0.9,1.7,0.9, 0.0,1.0,0.0, // c1
						0.4,1.7,1.1, 0.0,1.0,0.0, // a1
						-0.7,1.4,0.7, 0.0,1.0,0.0, // c

						//102
						//-0.7
						-1.1,1.7,0.4 , 0.0,1.0,0.0, // a2
						-0.9,1.7,0.9, 0.0,1.0,0.0, // c1
						-0.7,1.4,0.7, 0.0,1.0,0.0, // c

						//105
						-1.1,1.7,0.4, 0.0,1.0,0.0, // a2
						-0.7,1.4,0.7, 0.0,1.0,0.0, // c
						-0.7,1.4,-0.7, 0.0,1.0,0.0, // b

						//108
						-0.9,1.7,-0.9, 0.0,1.0,0.0, // b2
						-1.1,1.7,0.4 , 0.0,1.0,0.0, // a2
						-0.7,1.4,-0.7, 0.0,1.0,0.0, // g

						//101
						0.4,1.7,-1.1, 0.0,1.0,0.0, // a3
						-0.9,1.7,-0.9, 0.0,1.0,0.0, // b2
						-0.7,1.4,-0.7, 0.0,1.0,0.0, // g

						//104
						0.4,1.7,-1.1, 0.0,1.0,0.0, // a3
						-0.7,1.4,-0.7, 0.0,1.0,0.0, // g
						0.7,1.4,-0.7, 0.0,1.0,0.0, // v

						//107
						0.9,1.7,-0.9, 0.0,1.0,0.0, // b3
						0.4,1.7,-1.1, 0.0,1.0,0.0, // a3
						0.7,1.4,-0.7, 0.0,1.0,0.0, // v

						//110
						1.1,1.7,0.4, 0.0,1.0,0.0, // a4
						0.9,1.7,-0.9, 0.0,1.0,0.0, // b3
						0.7,1.4,-0.4, 0.0,1.0,0.0, // v

						//113
						1.1,1.7,0.4, 0.0,1.0,0.0, // a4
						0.7,1.4,-0.7, 0.0,1.0,0.0, // v
						0.7,1.4,0.7, 0.0,1.0,0.0, // d

						//116
						0.9,1.7,0.9, 0.0,1.0,0.0, // b1
						1.1,1.7,0.4, 0.0,1.0,0.0, // a4
						0.7,1.4,0.7, 0.0,1.0,0.0 // d



					];
				
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc=[0,0,0];
					this.rot=[0,0,0];
				}
				Update()
				{
					//this.rot[1] += this.angVelocity[1];
				}
				
			}

			class Bush extends GameObject
			{
				constructor()
				{
					// 132 for the whole
					// 90 without the bottom cap 
					super(132, gl.TRIANGLES);
					this.name = "Bush";
					this.angVelocity = [0,0,0];
					//this.isTrigger = false;
					this.buffer=gl.createBuffer();
					//this.colorBuffer = gl.createBuffer();
					
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices =
					[
						0.7,0.9,0.7, 0.0,1.0,0.0, // a
						-0.7,0.9,-0.7, 0.0,1.0,0.0, // b
						-0.7,0.9,0.7, 0.0,1.0,0.0, // c
						0.7,0.9,0.7, 0.0,1.0,0.0, // d
						-0.7,0.9,-0.7, 0.0,1.0,0.0, // g
						0.7,0.9,-0.7, 0.0,1.0,0.0, // v

						0.4,0.5,1.1, 0.0,1.0,0.0, // a1
						0.9,0.5,0.9, 0.0,1.0,0.0, // b1
						0.7,0.9,0.7, 0.0,1.0,0.0, // d

						0.4,0.5,1.1, 0.0,1.0,0.0,  // a1
						0.7,0.9,0.7, 0.0,1.0,0.0,  // d
						-0.7,0.9,0.7, 0.0,1.0,0.0, // c

						-0.9,0.5,0.9, 0.0,1.0,0.0, // c1
						0.4,0.5,1.1, 0.0,1.0,0.0, // a1
						-0.7,0.9,0.7, 0.0,1.0,0.0, // c

						//15
						-1.1,0.5,0.4 , 0.0,1.0,0.0, // a2
						-0.9,0.5,0.9, 0.0,1.0,0.0, // c1
						-0.7,0.9,0.7, 0.0,1.0,0.0, // c

						//18
						-1.1,0.5,0.4, 0.0,1.0,0.0, // a2
						-0.7,0.9,0.7, 0.0,1.0,0.0, // c
						-0.7,0.9,-0.7, 0.0,1.0,0.0, // b

						//21
						-0.9,0.5,-0.9, 0.0,1.0,0.0, // b2
						-1.1,0.5,0.4 , 0.0,1.0,0.0, // a2
						-0.7,0.9,-0.7, 0.0,1.0,0.0, // g

						//23
						0.4,0.5,-1.1, 0.0,1.0,0.0, // a3
						-0.9,0.5,-0.9, 0.0,1.0,0.0, // b2
						-0.7,0.9,-0.7, 0.0,1.0,0.0, // g

						//26
						0.4,0.5,-1.1, 0.0,1.0,0.0, // a3
						-0.7,0.9,-0.7, 0.0,1.0,0.0, // g
						0.7,0.9,-0.7, 0.0,1.0,0.0, // v

						//29
						0.9,0.5,-0.9, 0.0,1.0,0.0, // b3
						0.4,0.5,-1.1, 0.0,1.0,0.0, // a3
						0.7,0.9,-0.7, 0.0,1.0,0.0, // v

						//32
						1.1,0.5,0.4, 0.0,1.0,0.0, // a4
						0.9,0.5,-0.9, 0.0,1.0,0.0, // b3
						0.7,0.9,-0.7, 0.0,1.0,0.0, // v

						//35
						1.1,0.5,0.4, 0.0,1.0,0.0, // a4
						0.7,0.9,-0.7, 0.0,1.0,0.0, // v
						0.7,0.9,0.7, 0.0,1.0,0.0, // d

						//42 // mid top
						0.9,0.5,0.9, 0.0,1.0,0.0, // b1
						1.1,0.5,0.4, 0.0,1.0,0.0, // a4
						0.7,0.9,0.7, 0.0,1.0,0.0, // d

						//45
						1.1,0.5,0.4, 0.0,1.0,0.0, // a4
						0.9,0.5,0.9, 0.0,1.0,0.0, // b1
						0.9,0.2,0.9, 0.0,1.0,0.0, // a5

						//48
						1.1,0.5,0.4, 0.0,1.0,0.0, // a4
						0.9,0.2,0.9, 0.0,1.0,0.0, // a5
						1.1,0.2,0.4, 0.0,1.0,0.0, // b5

						//51
						0.9,0.5,-0.9, 0.0,1.0,0.0, // b3
						1.1,0.5,0.4, 0.0,1.0,0.0, // a4
						1.1,0.2,0.4, 0.0,1.0,0.0, // b5

						//54
						0.9,0.5,-0.9, 0.0,1.0,0.0, // b3
						1.1,0.2,0.4, 0.0,1.0,0.0, // b5
						0.9,0.2,-0.9, 0.0,1.0,0.0, // a6

						//57
						0.4,0.5,-1.1, 0.0,1.0,0.0, // a3
						0.9,0.5,-0.9, 0.0,1.0,0.0, // b3
						0.9,0.2,-0.9, 0.0,1.0,0.0, // a6

						//60
						0.4,0.5,-1.1, 0.0,1.0,0.0, // a3
						0.9,0.2,-0.9, 0.0,1.0,0.0, // a6
						0.4,0.2,-1.1, 0.0,1.0,0.0, // b6

						-0.9,0.5,-0.9, 0.0,1.0,0.0, // b2
						0.4,0.5,-1.1, 0.0,1.0,0.0, // a3
						0.4,0.2,-1.1, 0.0,1.0,0.0, // b6

						-0.9,0.5,-0.9, 0.0,1.0,0.0, // b2
						0.4,0.2,-1.1, 0.0,1.0,0.0, // b6
						-0.9,0.2,-0.9, 0.0,1.0,0.0, // a7

						//69
						-1.1,0.5,0.4 , 0.0,1.0,0.0, // a2
						-0.9,0.5,-0.9, 0.0,1.0,0.0, // b2
						-0.9,0.2,-0.9, 0.0,1.0,0.0, // a7

						//72
						-1.1,0.5,0.4 , 0.0,1.0,0.0, // a2
						-0.9,0.2,-0.9, 0.0,1.0,0.0, // a7
						-1.1,0.2,0.4, 0.0,1.0,0.0, // a8

						//75
						-0.9,0.5,0.9, 0.0,1.0,0.0, // c1
						-1.1,0.5,0.4 , 0.0,1.0,0.0, // a2
						-1.1,0.2,0.4, 0.0,1.0,0.0, // a8

						//78
						-0.9,0.5,0.9, 0.0,1.0,0.0, // c1
						-1.1,0.2,0.4, 0.0,1.0,0.0, // a8
						-0.9,0.2,0.9, 0.0,1.0,0.0, // b8

						//80
						0.4,0.5,1.1, 0.0,1.0,0.0, // a1
						-0.9,0.5,0.9, 0.0,1.0,0.0, // c1
						-0.9,0.2,0.9, 0.0,1.0,0.0, // b8

						//83
						0.4,0.5,1.1, 0.0,1.0,0.0, // a1
						-0.9,0.2,0.9, 0.0,1.0,0.0, // b8
						0.4,0.2,1.1, 0.0,1.0,0.0, // a9

						//86
						0.9,0.5,0.9, 0.0,1.0,0.0, // b1
						0.4,0.5,1.1, 0.0,1.0,0.0, // a1
						0.4,0.2,1.1, 0.0,1.0,0.0, // a9

						//90
						0.9,0.5,0.9, 0.0,1.0,0.0, // b1
						0.4,0.2,1.1, 0.0,1.0,0.0, // a9
						0.9,0.2,0.9, 0.0,1.0,0.0, // a5


						// Bottom cap


						0.7,-0.1,0.7, 0.0,1.0,0.0, // a
						-0.7,-0.1,-0.7, 0.0,1.0,0.0, // b
						-0.7,-0.1,0.7, 0.0,1.0,0.0, // c
						0.7,-0.1,0.7, 0.0,1.0,0.0, // d
						-0.7,-0.1,-0.7, 0.0,1.0,0.0, // g
						0.7,-0.1,-0.7, 0.0,1.0,0.0, // v




						0.4,0.2,1.1, 0.0,1.0,0.0, // a1
						0.9,0.2,0.9, 0.0,1.0,0.0, // b1
						0.7,-0.1,0.7, 0.0,1.0,0.0, // d

						0.4,0.2,1.1, 0.0,1.0,0.0,  // a1
						0.7,-0.1,0.7, 0.0,1.0,0.0,  // d
						-0.7,-0.1,0.7, 0.0,1.0,0.0, // c

						//99
						-0.9,0.2,0.9, 0.0,1.0,0.0, // c1
						0.4,0.2,1.1, 0.0,1.0,0.0, // a1
						-0.7,-0.1,0.7, 0.0,1.0,0.0, // c

						//102
						//-0.7
						-1.1,0.2,0.4 , 0.0,1.0,0.0, // a2
						-0.9,0.2,0.9, 0.0,1.0,0.0, // c1
						-0.7,-0.1,0.7, 0.0,1.0,0.0, // c

						//105
						-1.1,0.2,0.4, 0.0,1.0,0.0, // a2
						-0.7,-0.1,0.7, 0.0,1.0,0.0, // c
						-0.7,-0.1,-0.7, 0.0,1.0,0.0, // b

						//108
						-0.9,0.2,-0.9, 0.0,1.0,0.0, // b2
						-1.1,0.2,0.4 , 0.0,1.0,0.0, // a2
						-0.7,-0.1,-0.7, 0.0,1.0,0.0, // g

						//101
						0.4,0.2,-1.1, 0.0,1.0,0.0, // a3
						-0.9,0.2,-0.9, 0.0,1.0,0.0, // b2
						-0.7,-0.1,-0.7, 0.0,1.0,0.0, // g

						//104
						0.4,0.2,-1.1, 0.0,1.0,0.0, // a3
						-0.7,-0.1,-0.7, 0.0,1.0,0.0, // g
						0.7,-0.1,-0.7, 0.0,1.0,0.0, // v

						//107
						0.9,0.2,-0.9, 0.0,1.0,0.0, // b3
						0.4,0.2,-1.1, 0.0,1.0,0.0, // a3
						0.7,-0.1,-0.7, 0.0,1.0,0.0, // v

						//110
						1.1,0.2,0.4, 0.0,1.0,0.0, // a4
						0.9,0.2,-0.9, 0.0,1.0,0.0, // b3
						0.7,-0.1,-0.4, 0.0,1.0,0.0, // v

						//113
						1.1,0.2,0.4, 0.0,1.0,0.0, // a4
						0.7,-0.1,-0.7, 0.0,1.0,0.0, // v
						0.7,-0.1,0.7, 0.0,1.0,0.0, // d

						//116
						0.9,0.2,0.9, 0.0,1.0,0.0, // b1
						1.1,0.2,0.4, 0.0,1.0,0.0, // a4
						0.7,-0.1,0.7, 0.0,1.0,0.0, // d





					];
				
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc=[0,0,0];
					this.rot=[0,0,0];
				}

				Update()
				{
					//nothing
				}
					
			}

			class Rock extends GameObject
			{
				constructor()
				{
					super(90, gl.TRIANGLES);
					this.name = "Rock";
					this.angVelocity = [0,0,0];
					//this.isTrigger = false;
					this.buffer=gl.createBuffer();
					//this.colorBuffer = gl.createBuffer();
					
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

					this.vertices =
					[
						0.3,0.8,0.3, 0.65,0.65,0.65, // a
						-0.3,0.8,-0.3, 0.65,0.65,0.65, // b
						-0.3,0.8,0.3, 0.65,0.65,0.65, // c
						0.3,0.8,0.3, 0.65,0.65,0.65, // d
						-0.3,0.8,-0.3, 0.65,0.65,0.65, // g
						0.3,0.8,-0.3, 0.65,0.65,0.65, // v

						0.0,-0.2,0.7, 0.65,0.65,0.65, // a1
						0.5,-0.2,0.5, 0.65,0.65,0.65, // b1
						0.3,0.8,0.3, 0.65,0.65,0.65, // d

						0.0,-0.2,0.7, 0.65,0.65,0.65,  // a1
						0.3,0.8,0.3, 0.65,0.65,0.65,  // d
						-0.3,0.8,0.3, 0.65,0.65,0.65, // c

						-0.5,-0.2,0.5, 0.65,0.65,0.65, // c1
						0.0,-0.2,0.7, 0.65,0.65,0.65, // a1
						-0.3,0.8,0.3, 0.65,0.65,0.65, // c

						//15
						-0.7,-0.2,0.0 , 0.65,0.65,0.65, // a2
						-0.5,-0.2,0.5, 0.65,0.65,0.65, // c1
						-0.3,0.8,0.3, 0.65,0.65,0.65, // c

						//16
						-0.7,-0.2,0.0, 0.65,0.65,0.65, // a2
						-0.3,0.8,0.3, 0.65,0.65,0.65, // c
						-0.3,0.8,-0.3, 0.65,0.65,0.65, // b

						//21
						-0.5,-0.2,-0.5, 0.65,0.65,0.65, // b2
						-0.7,-0.2,0.0 , 0.65,0.65,0.65, // a2
						-0.3,0.8,-0.3, 0.65,0.65,0.65, // g

						//23
						0.0,-0.2,-0.7, 0.65,0.65,0.65, // a3
						-0.5,-0.2,-0.5, 0.65,0.65,0.65, // b2
						-0.3,0.8,-0.3, 0.65,0.65,0.65, // g

						//26
						0.0,-0.2,-0.7, 0.65,0.65,0.65, // a3
						-0.3,0.8,-0.3, 0.65,0.65,0.65, // g
						0.3,0.8,-0.3, 0.65,0.65,0.65, // v

						//29
						0.5,-0.2,-0.5, 0.65,0.65,0.65, // b3
						0.0,-0.2,-0.7, 0.65,0.65,0.65, // a3
						0.3,0.8,-0.3, 0.65,0.65,0.65, // v

						//32
						0.7,-0.2,0.0, 0.65,0.65,0.65, // a4
						0.5,-0.2,-0.5, 0.65,0.65,0.65, // b3
						0.3,0.8,-0.3, 0.65,0.65,0.65, // v

						//35
						0.7,-0.2,0.0, 0.65,0.65,0.65, // a4
						0.3,0.8,-0.3, 0.65,0.65,0.65, // v
						0.3,0.8,0.3, 0.65,0.65,0.65, // d

						//42
						0.5,-0.2,0.5, 0.65,0.65,0.65, // b1
						0.7,-0.2,0.0, 0.65,0.65,0.65, // a4
						0.3,0.8,0.3, 0.65,0.65,0.65, // d

						//45
						0.7,-0.2,0.0, 0.65,0.65,0.65, // a4
						0.5,-0.2,0.5, 0.65,0.65,0.65, // b1
						0.5,-0.5,0.5, 0.65,0.65,0.65, // a5

						//48
						0.7,-0.2,0.0, 0.65,0.65,0.65, // a4
						0.5,-0.5,0.5, 0.65,0.65,0.65, // a5
						0.7,-0.5,0.0, 0.65,0.65,0.65, // b5

						//51
						0.5,-0.2,-0.5, 0.65,0.65,0.65, // b3
						0.7,-0.2,0.0, 0.65,0.65,0.65, // a4
						0.7,-0.5,0.0, 0.65,0.65,0.65, // b5

						//54
						0.5,-0.2,-0.5, 0.65,0.65,0.65, // b3
						0.7,-0.5,0.0, 0.65,0.65,0.65, // b5
						0.5,-0.5,-0.5, 0.65,0.65,0.65, // a6

						//57
						0.0,-0.2,-0.7, 0.65,0.65,0.65, // a3
						0.5,-0.2,-0.5, 0.65,0.65,0.65, // b3
						0.5,-0.5,-0.5, 0.65,0.65,0.65, // a6

						//60
						0.0,-0.2,-0.7, 0.65,0.65,0.65, // a3
						0.5,-0.5,-0.5, 0.65,0.65,0.65, // a6
						0.0,-0.5,-0.7, 0.65,0.65,0.65, // b6

						-0.5,-0.2,-0.5, 0.65,0.65,0.65, // b2
						0.0,-0.2,-0.7, 0.65,0.65,0.65, // a3
						0.0,-0.5,-0.7, 0.65,0.65,0.65, // b6

						-0.5,-0.2,-0.5, 0.65,0.65,0.65, // b2
						0.0,-0.5,-0.7, 0.65,0.65,0.65, // b6
						-0.5,-0.5,-0.5, 0.65,0.65,0.65, // a7

						//69
						-0.7,-0.2,0.0 , 0.65,0.65,0.65, // a2
						-0.5,-0.2,-0.5, 0.65,0.65,0.65, // b2
						-0.5,-0.5,-0.5, 0.65,0.65,0.65, // a7

						//72
						-0.7,-0.2,0.0 , 0.65,0.65,0.65, // a2
						-0.5,-0.5,-0.5, 0.65,0.65,0.65, // a7
						-0.7,-0.5,0.0, 0.65,0.65,0.65, // a8

						//75
						-0.5,-0.2,0.5, 0.65,0.65,0.65, // c1
						-0.7,-0.2,0.0 , 0.65,0.65,0.65, // a2
						-0.7,-0.5,0.0, 0.65,0.65,0.65, // a8

						//78
						-0.5,-0.2,0.5, 0.65,0.65,0.65, // c1
						-0.7,-0.5,0.0, 0.65,0.65,0.65, // a8
						-0.5,-0.5,0.5, 0.65,0.65,0.65, // b8

						//80
						0.0,-0.2,0.7, 0.65,0.65,0.65, // a1
						-0.5,-0.2,0.5, 0.65,0.65,0.65, // c1
						-0.5,-0.5,0.5, 0.65,0.65,0.65, // b8

						//83
						0.0,-0.2,0.7, 0.65,0.65,0.65, // a1
						-0.5,-0.5,0.5, 0.65,0.65,0.65, // b8
						0.0,-0.5,0.7, 0.65,0.65,0.65, // a9

						//86
						0.5,-0.2,0.5, 0.65,0.65,0.65, // b1
						0.0,-0.2,0.7, 0.65,0.65,0.65, // a1
						0.0,-0.5,0.7, 0.65,0.65,0.65, // a9

						//90
						0.5,-0.2,0.5, 0.65,0.65,0.65, // b1
						0.0,-0.5,0.7, 0.65,0.65,0.65, // a9
						0.5,-0.5,0.5, 0.65,0.65,0.65, // 

						// Was 0.2

					];

					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc=[0,0,0];
					this.rot=[0,0,0];
				}

				Update()
				{
					//nothing
				}
			}

			class Torch extends GameObject
			{
				constructor()
				{
					super(24, gl.TRIANGLES);
					this.name = "Torch";
					//this.angVelocity = [0,0,0];
					//this.isTrigger = false;
					this.buffer=gl.createBuffer();
					//this.colorBuffer = gl.createBuffer();
					
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

					this.vertices = 
					[
						// Front face
						-0.05,-0.05,0.1, 0.63,0.26,0.0,
						0.05,-1.5,0.1, 0.63,0.26,0.0,
						-0.05,-1.5,0.1, 0.63,0.26,0.0,
						-0.05,-0.05,0.1, 0.63,0.26,0.0,
						0.05,-0.05,0.1, 0.63,0.26,0.0,
						0.05,-1.5,0.1, 0.63,0.26,0.0,

						// Left face
						-0.05,-0.05,0.0, 0.63,0.26,0.0,
						-0.05,-1.5,0.1, 0.63,0.26,0.0,
						-0.05,-1.5,0.0, 0.63,0.26,0.0,
						-0.05,-0.05,0.0, 0.63,0.26,0.0,
						-0.05,-0.05,0.1, 0.63,0.26,0.0,
						-0.05,-1.5,0.1, 0.63,0.26,0.0,

						// Right face
						0.05,-0.05,0.0, 0.63,0.26,0.0,
						0.05,-1.5,0.1, 0.63,0.26,0.0,
						0.05,-1.5,0.0, 0.63,0.26,0.0,
						0.05,-0.05,0.0, 0.63,0.26,0.0,
						0.05,-0.05,0.1, 0.63,0.26,0.0,
						0.05,-1.5,0.1, 0.63,0.26,0.0,

						// Back face
						-0.05,-0.05,0.0, 0.63,0.26,0.0,
						0.05,-1.5,0.0, 0.63,0.26,0.0,
						-0.05,-1.5,0.0, 0.63,0.26,0.0,
						-0.05,-0.05,0.0, 0.63,0.26,0.0,
						0.05,-0.05,0.0, 0.63,0.26,0.0,
						0.05,-1.5,0.0, 0.63,0.26,0.0,
						
						

					];

					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);

				}

				Update()
				{
					//Nothing
				}
			}


			class Camera extends GameObject
			{
				constructor()
				{
					super(0, gl.TRIANGLES);
					this.name = "Camera";
					this.loc = [0,0,0];
					this.rot = [0,0,0];
						
				}
				Update()
				{
					// All of this is from the Player update
					this.velocity = [0,0,0];
					this.angVelocity = [0,0,0];
					if("A" in m.Keys && m.Keys["A"])
					{
						// 1 == rotate y
						// If we want to rotate the camera to move
						// right then i have to rotate the entire world to the
						// left. So in this case we make sure to rotate counter-clockwise
						this.angVelocity[1] -=.02;		//euler angles x,y,z
					}
					if("D" in m.Keys && m.Keys["D"])
					{
						// Movign the world 
						// Same idea of roation applies here! In this case to rotate the camera
						// left, we make suere to rotate the world to the right (clock-wise)
						this.angVelocity[1] +=.02;
					}
					
					// Make sure to rotate the direction vectors by the same ammount!
					this.transform.doRotations(this.rot);
					// Want to move in the z direction which is where the camera is pointing
					var tempF = this.transform.forward;
					if("W" in m.Keys && m.Keys["W"])	// Move forward 
					{
						for(var i =0; i < 3; i++)
						{
							this.velocity[i] += tempF[i]*.1; 
						}
					}
					if("S" in m.Keys && m.Keys["S"])	// Move backwards
					{
						for(var i =0; i < 3; i++)
						{
							this.velocity[i] -= tempF[i]*.1; 
						}
					}

					this.Move();
				}
				Render(program)
				{
					var camLoc  = gl.getUniformLocation(program,'worldLoc');
					gl.uniform3fv(camLoc,new Float32Array(this.loc));
					var worldLoc = gl.getUniformLocation(program,'worldRotation');
					gl.uniform3fv(worldLoc,new Float32Array(this.rot));
				}

				OnCollisionEnter(other)
				{
					if(other.name == "Hex")
						console.log("Hex collided with camera");

					if(other.name == "Boundary")
						console.log("Boundary collided with camera");
				}

				OnTriggerEnter(other)
				{
					if(other.name == "Hitbox")
						console.log("Hitbox collided with Camera");
				}
				
				
			}

			class Boundary extends GameObject
			{
				constructor()
				{
					super(0,gl.TRIANGLES);
					this.name = "Boundary";
					this.loc = [0,0,0];
					this.rot = [0,0,0];
				}

				Update()
				{
					// Nothing
				}

				Render(program)
				{
					// Nothing

				}
			}

			class Enemy extends GameObject
			{
				constructor()
				{
					super(24, gl.TRIANGLES);
					this.name = "Enemy";
					this.isTrigger = true;
					this.buffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				
					this.vertices =
					[	
						// Top
						-0.5, 0.5, -0.5,   0.5, 0.5, 0.5,
						-0.5, 0.5, 0.5,    0.5, 0.5, 0.5,
						0.5, 0.5, 0.5,     0.5, 0.5, 0.5,
						0.5, 0.5, -0.5,    0.5, 0.5, 0.5,

						// Left
						-0.5, 0.5, 0.5,    0.75, 0.25, 0.5,
						-0.5, -0.5, 0.5,   0.75, 0.25, 0.5,
						-0.5, -0.5, -0.5,  0.75, 0.25, 0.5,
						-0.5, 0.5, -0.5,   0.75, 0.25, 0.5,

						// Right
						0.5, 0.5, 0.5,    0.25, 0.25, 0.75,
						0.5, -0.5, 0.5,   0.25, 0.25, 0.75,
						0.5, -0.5, -0.5,  0.25, 0.25, 0.75,
						0.5, 0.5, -0.5,   0.25, 0.25, 0.75,

						// Front
						0.5, 0.5, 0.5,    1.0, 0.0, 0.15,
						0.5, -0.5, 0.5,    1.0, 0.0, 0.15,
						-0.5, -0.5, 0.5,    1.0, 0.0, 0.15,
						-0.5, 0.5, 0.5,    1.0, 0.0, 0.15,

						// Back
						0.5, 0.5, -0.5,    0.0, 1.0, 0.15,
						0.5, -0.5, -0.5,    0.0, 1.0, 0.15,
						-0.5, -0.5, -0.5,    0.0, 1.0, 0.15,
						-0.5, 0.5, -0.5,    0.0, 1.0, 0.15,

						// Bottom
						-0.5, -0.5, -0.5,   0.5, 0.5, 1.0,
						-0.5, -0.5, 0.5,    0.5, 0.5, 1.0,
						0.5, -0.5, 0.5,     0.5, 0.5, 1.0,
						0.5, -0.5, -0.5,    0.5, 0.5, 1.0
						
					];
				
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					//this.velocity = [0.007,0,0];	// We want enemy object to already be moving off rip
					this.sign = 0;		// Sign helps in determining in which direction to go when colliding with a wall
					// Move the enemy at constant speed
					this.velocity = [0.08,0,0];
					// Variable for holding the uniform that the enemy is connected to
					this.uniform;
					// Composition
					this.hitbox;
					
				}

				Update()
				{
					this.hitbox.loc = [this.loc[0], 0, this.loc[2]];
					
					this.Move();

					var enemyLoc = gl.getUniformLocation(m.myWEBGL.program,this.uniform);
					gl.uniform3fv(enemyLoc, this.loc);
				}

				OnTriggerEnter(other)
				{
					if(other.name == "Boundary")
					{
						console.log("wall collision");
						// 0 == positive movement (right)
						if(this.sign == 0)
						{
							this.sign = 1;
						}
						else	// left movement (left)
						{
							this.sign = 0;
						}
						this.velocity = this.velocity.map(value => value * -1);
					}

					if(other.name == "Camera")
					{
						console.log("Camera collided with enemy");
						
					}
				}

			}

			class Hitbox extends GameObject
			{
				constructor()
				{
					super(0,gl.TRIANGLES);
					this.name = "Hitbox";
					this.isTrigger = true;
					this.loc = [0,0,0];
					this.rot = [0,0,0];
				}

				Update()
				{
					// Make the hitbox look out for any camera collisions
					this.Move();
				}

				Render(program)
				{
					// Nothing
				}

				OnTriggerEnter(other)
				{
					// If the camera collides with the spotlight then send it back to spawn
					if(other.name == "Camera")
					{
						other.loc = [0,0,0];
					}
				}
			}

			class Moon extends GameObject
			{
				constructor()
				{
					super(6,gl.TRIANGLES);
					this.name = "Moon";

					this.buffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				
					this.vertices =
					[	
						-45.0,45.0,0, 0.99,0.99,0.99,
						45.0,-45.0,0, 0.99,0.99,0.99,
						-45.0,-45.0,0, 0.99,0.99,0.99,

						-45.0,45.0,0, 0.99,0.99,0.99,
						45.0,45.0,0, 0.99,0.99,0.99,
						45.0,-45.0,0, 0.99,0.99,0.99,
						
					];
				
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					

				}

				Update()
				{
					// Nothing
				}
			}
		</script>



		<script>
		class main
		{	
			constructor()
			{
				this.Visual = [];
				this.Solid = [];
				this.Trigger = [];
				this.ObjectCounter = 0;			

				this.myWEBGL = new WebGL_Interface();
				this.myTriangle = [];
				this.Keys = [];

				for(var i = 0; i < 60; i++)
				{
					var randX = Math.floor(Math.random() * 61) - 30;
					var randZ = Math.floor(Math.random() * 101) - 105;

					this.CreateObject(1,Hex,[randX,0,randZ],[0,0,0],0.5,0.5,0.5);
					this.CreateObject(
						1,
						Rock,
						[Math.floor(Math.random() * 61) - 30, 0, Math.floor(Math.random() * 101) - 105],
						[0,0,0],
						0.7,0.8,0.8
					)

				}


				this.CreateObject(1,Camera,[0,0,0],[0,0,0],0.3,0.3,0.3);
				this.CreateObject(2,Ground,[0,-.5,0],[0,0,0],0,0,0);

				this.CreateObject(1,Boundary,[0,0,-110],[0,0,0],35,8,1);
				this.CreateObject(1,Boundary,[-35,0,-55],[0,1.56,0],1,8,58);
				this.CreateObject(1,Boundary,[35,0,-55],[0,-1.56,0],1,8,58);

				//var enemy1 = this.CreateObject(2,Enemy,[0,6,-20],[0,0,0],0.5,0.5,0.5);
				//enemy1.uniform = 'spotLoc1';
				//enemy1.hitbox = this.CreateObject(2,Hitbox,[enemy1.loc[0],0,enemy1.loc[2]],[0,0,0],3,3,3);

				//this.CreateObject(2,Hitbox,[0,0,-3],[0,0,0],0.5,0.5,0.5);
				
				//var enemyLoc = gl.getUniformLocation(this.myWEBGL.program,'spotLoc1');
				//gl.uniform3fv(enemyLoc, enemy1.loc);

				// Creating the moon
				this.CreateObject(0,Moon,[300,160,300],[0,4,0],0.5,0.5,0);

				// Setting up a random location for the point lights
				for(var i = 0; i < 5; i++)
				{
					// Generating 5 random torches
					var torch = this.CreateObject(2,Torch,[Math.floor(Math.random() * 61) - 30,0,Math.floor(Math.random() * 101) - 105],[0,0,0],0.1,1.6,0.1);
					var torchLoc = gl.getUniformLocation(this.myWEBGL.program,'torchLoc'+(i+1));
					gl.uniform3fv(torchLoc, torch.loc);

					// Generating 5 random enemies with spotlights
					var enemy = this.CreateObject(2,Enemy,[Math.floor(Math.random() * 61) - 30,6,Math.floor(Math.random() * 101) - 105],[0,0,0],0.5,0.5,0.5);
					// Have to reference the uniform multiple times
					enemy.uniform = 'spotLoc'+(i+1);
					enemy.hitbox = this.CreateObject(2,Hitbox,[enemy.loc[0],0,enemy.loc[2]],[0,0,0],3,3,3);
				}
			
			}
			
			UpdateAll()
			{
				for(var i in this.Visual)
				{
					this.Visual[i].Update();
				}
				for(var i in this.Solid)
				{
					this.Solid[i].Update();
				}
				for(var i in this.Trigger)
				{
					this.Trigger[i].Update();
				}
			
			}
			
			RenderAll()
			{
				gl.clear(gl.COLOR_BUFFER_BIT);
				for(var i in this.Visual)
				{
					this.Visual[i].Render(this.myWEBGL.program);
				}
				for(var i in this.Solid)
				{
					this.Solid[i].Render(this.myWEBGL.program);
				}
				for(var i in this.Trigger)
				{
					this.Trigger[i].Render(this.myWEBGL.program);
				}
			
			}
			
			CheckCollision(name1,loc1,rad1X,rad1Y,rad1Z,name2,loc2,rad2X,rad2Y,rad2Z)
			{
				// X, Y and Z radiuses for each object
				var totalRange = rad1X + rad2X;
				var totalRangeY = rad1Y + rad2Y;
				var totalRangeZ = rad1Z + rad2Z;
				// Return true if they collide, false if they don't.
				
				// Need to flip the z of the camera because internally, its moving in the positive z direction when
				// W is pressed. This will cause issues because its initially looking in the negative z direction
				if(name1 == "Camera")
				{
					
					if(Math.abs(loc1[0]-loc2[0]) < totalRange && Math.abs(loc1[1]-loc2[1]) < totalRangeY && Math.abs(-1*loc1[2]-loc2[2]) < totalRangeZ)
						return true;

					return false;
				}
				else if(name2 == "Camera")
				{
					if(Math.abs(loc1[0]-loc2[0]) < totalRange && Math.abs(loc1[1]-loc2[1]) < totalRangeY && Math.abs(loc1[2]-(-1*loc2[2])) < totalRangeZ)
						return true;

					return false;

				}
				else
				{
					// Its important to add both locations when checking the z axis. If gem is at -5, doing loc1[2] - loc2[2] will only
					// cause the distance to grow as we approach the gem which is the opposite of what we want. Instead we subtract and then 
					// take the absolute value. This should also probably apply to x and y in 3d space loc1[2]-loc2[2]
					if(Math.abs(loc1[0]-loc2[0]) < totalRange && Math.abs(loc1[1]-loc2[1]) < totalRangeY && Math.abs(loc1[2]-loc2[2]) < totalRangeZ)
						return true;

					return false;

				}
				
				
			}
			
			CreateObject(type, prefab, loc, rot, rX, rY, rZ)
			{
				//type 0 = visual
				//type 1 = solid
				//type 2 = trigger
				var temp = new prefab; //Yes this dark sorcery will work.
				var id = "ID"+this.ObjectCounter;
				this.ObjectCounter ++;
				temp.id = id;
				temp.prefab = prefab;
				temp.loc = loc;
				temp.rot = rot;
				temp.cRadX = rX;
				temp.cRadY = rY;
				temp.cRadZ = rZ;
					switch(type)
					{
						case 0:
							this.Visual[id] = temp;
						break;
						case 1:
							this.Solid[id] = temp;
						break;
						case 2:
							this.Trigger[id] = temp;
						break;
						default:
						break;
					}		
				//We can return the game object to the calling function
				//Should the user want to set custom names or properties on it.
				return temp;
			}
			
			
			DestroyObject(id)
			{
				if(id in this.Visual)
				{
					delete this.Visual[id];
				}
				if(id in this.Solid)
				{
					delete this.Solid[id];
				}

				if(id in this.Trigger)
				{
					delete this.Trigger[id];
				}
			}
			
			KeyDown(event)
			{
				this.Keys[String.fromCharCode(event.keyCode)] = true;
				//console.log(String.fromCharCode(event.keyCode) +" should be true - "+this.Keys[String.fromCharCode(event.keyCode)]);
			}
			
			KeyUp(event)
			{
				this.Keys[String.fromCharCode(event.keyCode)] = false;
				//console.log(String.fromCharCode(event.keyCode) +" should be false - "+this.Keys[String.fromCharCode(event.keyCode)]);
			}
			
			MouseClick(event)
			{
				var rect = canvas.getBoundingClientRect();
				var realX = event.clientX - rect.left;
				var realY = event.clientY - rect.top;
				console.log(realX+","+realY);
				var x = -1 + 2*realX/myCanvas.width;
				var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
				console.log("The click occurred on "+x+","+y);
			}

			
			//Static call backs go down here
			//   |
			//  \ /
			//   v
			static keyD(event)
			{
				m.KeyDown(event);
			}
			static keyU(event)
			{
				m.KeyUp(event);
			}

			static mouseH(event)
			{
				m.MouseClick(event);
			}
			
			static MainLoop()
			{
				m.UpdateAll();
				m.RenderAll();
				requestAnimationFrame(main.MainLoop);
			}

		}
		
		
		</script>
		
		

	</Head>
	<BODY style="padding: 15px;">
		<HEADER>
		
		</HEADER>
		
		<h1 style="color: blueviolet;">Spooky Forest!</h1>
		<CANVAS id="myCanvas" width="1470" height="780" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>
		
		
		
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			var m = new main();
			window.onkeydown = main.keyD;
			window.onkeyup = main.keyU;
			canvas.addEventListener("click",main.mouseH);
			/*
			for(var i =-10; i <=20; i ++)
			{
				for(var j =-10; j < 20; j ++)
				{
					m.CreateObject(2, D4, [j,i,-25],[0,0,0],0.5,0.5,0.5);
				}
			}
			*/
			

			requestAnimationFrame(main.MainLoop);	
			
			
		</SCRIPT>
		
		<FOOTER>
		
		</FOOTER>

		
	</BODY>
	
</HTML>
		
		